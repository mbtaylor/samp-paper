%% A&C uses 5p
\documentclass[5p]{elsarticle}

\usepackage{hyperref}
\usepackage{graphicx}

\usepackage{xcolor}  % for draft highlighting
\newcommand{\todo}{\color{gray}}

\journal{Astronomy \& Computing}

%% A&C uses model2-names (Harvard)
\bibliographystyle{model2-names}\biboptions{authoryear}

%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{frontmatter}

\title{SAMP, the Simple Applications Messaging Protocol}

%% Group authors per affiliation:
\author[bristol]{M.~B.~Taylor}
\ead{m.b.taylor@bristol.ac.uk}
\author[cds]{T.~Boch}
\author[google]{J.Taylor}

\address[bristol]{H.~H.~Wills Physics Laboratory, University of Bristol, UK}
\address[cds]{CDS, Observatoire Astronomique de Strasbourg, France}
\address[google]{Google, USA}

\begin{abstract}
SAMP, the Simple Applications Messaging Protocol, is a
hub-based communication standard for the exchange of data and control
between participating client applications.
It has been developed within the context of the Virtual Observatory
with the aim of enabling specialised data analysis tools to cooperate
as a loosely integrated suite, and is now in use by many and varied
desktop and web-based applications dealing with astronomical data.
This paper reviews the requirements and design principles that led to
SAMP's specification, provides a high-level description of the protocol,
and discusses some of its common and possible future usage patterns.
\end{abstract}

% from http://dl.acm.org/ccs_flat.cfm
\begin{keyword}
interoperability
message-passing
publish-subscribe
\end{keyword}

\end{frontmatter}

\begin{flushright}
{\tt \input{version}}
\end{flushright}

% use this in dot-delimited strings in place of a literal period.
\newcommand{\kdot}{.\linebreak[0]}

\section{Introduction}

% try to avoid re-writing adass_xxi intro
{\todo
Is this introduction too long/detailed?
Does it state the obvious?
Should there be a concrete example?
Is it too specific to a single use case (maybe more like history)?
The adass\_xxi intro is much more focussed, but don't want to cut'n'paste.

Maybe the intro needs to say: success requires a capable architecture,
useful semantics, and take-up in practice
}


Astronomical research requires complex and flexible manipulation
and processing of various different types of data.
Images, spectra, catalogues, time series, coverage maps and other data
types need their own special handling,
typically provided by specialist tools.
% and in many cases the required capabilities are provided by tools that
% specialise in a particular data type.
Data sets of different types meanwhile are usually related
in various ways arising from their physical origin,
for instance
catalogues are often derived from images and best understood in
conjunction with them, and
spectra and time series usually originate from specific sky positions
or regions which may be represented on images and described by
catalogue entries.
To extract scientific meaning from the data it is usually necessary
to exploit these linkages between data items as well as the
internal structure of each.

The working astronomer therefore uses a selection of different tools,
each specialising in a particular type of data or manipulation,
for different data sets and different tasks,
and has to integrate these together in a way that takes account of
the relationships of the data items under consideration.
This situation is not specific to the Virtual Observatory,
but the wealth of heterogeneous data available from the VO,
sometimes requiring the use of additional data discovery tools,
accentuates these issues in the VO context.

For batch or pipeline-type processing the required tool integration
is usually, in terms of data flow, fairly straightforward:
the output of one step can be fed to the input of the next as a file,
stream of bytes, or some kind of parameter list,
often under the control of a script of some kind.

During the exploratory or interactive phase of data analysis however,
this traditional model of tool integration is less satisfactory.
Within a given GUI analysis
tool it is usual to interact with the data using
mouse and keyboard gestures to perform actions like selection or
navigation with instant visual feedback, in many cases with some
kind of internal linkage between different data views.
But communicating such actions or their results between different
tools tends to be much more cumbersome.
A way can often be found to reflect a result generated by one tool
in the state of another, for instance by reading sky coordinates
reported by one tool and typing or pasting them into another,
or saving an intermediate result from one tool to temporary storage
and reloading it into another, but it can be fiddly and tedious,
especially if similar actions are required repeatedly.
This lack of convenience is more than just an annoyance, it can
interrupt the flow of the data exploration, reduce the parameter
space able to be investigated, and effectively stifle discovery
of relationships present in the data.

From this point of view, a single monolithic astronomical data analysis
user application providing the best available facilities for
interactive presentation, manipulation and analysis of all kinds of
astronomical data and their interrelationships seems an attractive prospect.
In reality of course, no such one-stop analysis tool exists.
The obvious practical difficulties aside, it is not even clear
that deviating so far from the Unix philosophy of
``Make each program do one thing well'' \citep{mcilroy1978}
would be desirable.

These considerations have driven the development of a framework
for communication between independently-developed software items,
written in different languages and running in different processes.
Such applications can thus be made to appear to the user
as a loosely integrated suite of cooperating tools,
providing facilities such as data exchange, linked views and
peer-to-peer or client-server remote control.
Although communication between interactive desktop tools was the
original stimulus for what is now SAMP, the framework is flexible
enough to support other usage patterns as well.

Two previous papers on SAMP have been presented at the ADASS conference
series:
\citet{adassxxi_paper} briefly outlines the architecture and explains
the Web Profile, and \citet{adassxxii_bof} lists some existing
client libraries.
This paper discusses the protocol design and communication model
in somewhat more detail, though at a higher level than given by the
standard itself \citep{samp_std}, and reviews existing and current
usage, considering lessons learned and possible future directions.
Section \ref{sec:history} outlines its evolution from
the earlier PLASTIC protocol,
section \ref{sec:protocol} presents a description of the protocol itself
along with some of the thinking for the design behind it,
section \ref{sec:usage} considers its use in practice, and
section \ref{sec:conclusion} concludes by reviewing the current status
and possible future directions for SAMP.

{\todo
\section{History} \label{sec:history}
 
  \begin{itemize}
  \item SC4DEVO ... VOTech ... VODesktop ... AstroGrid Runtime ...
  \item PLASTIC\citep{plastic_note} ... pub/sub ... XML-RPC/Java/RMILite
  \item Lessons learned from PLASTIC
  \end{itemize}
}


\section{Interoperable Design} \label{sec:design}

The overriding objective for the design of SAMP
has been to foster interoperability in practice.
This requires not just a messaging system with sufficient communication
capabilities, but also one which developers of popular analysis tools,
and ideally private scripts as well,
are actually willing and able to integrate into their software.
To achieve this, a number of principles
have been followed as much as possible.

In the first place, it is as much as possible platform independent.
The definition of the protocol is not dependent on or biassed
towards use of particular implementation languages or operating systems.
It differs in this respect from the earlier PLASTIC protocol,
which while accessible from any language was in parts defined with
reference to the Java platform, creating a perception which may
have discouraged takeup from the non-Java community.

Second, ease of adoption.
Application authors have in practice found basic use of 
SAMP to require little implementation effort.
In practice, availability of SAMP client libraries
developed within the SAMP community
for a number of implementation languages have been an important
factor in this.
However the communications are, by design, simple enough that
basic SAMP use is not hard to achieve given only an XML parser
and HTTP access capabilities.

Third, flexibility and extensibility.
Building into the system the capability to use it in ways
driven by the requirements of the client tools rather than
just those forseen by the standard authors increases its likely usefulness.

Finally, the approach has been above all pragmatic, favouring
the straightforward over the rigorous in cases of conflict.
For instance message delivery is not guaranteed, but can be 
expected to work most of the time.  The Standard Profile offers
a security model which will prevent casual interference
but may be vulnerable to determined attack.  Semantics are tagged
using short readable strings on the assumption of sensible choices
rather than URIs with guaranteed private namespaces.

These principles and their application, in some cases informed
by positive and negative lessons from the experience of PLASTIC,
might not be appropriate for all contexts
but have led to a messaging infrastructure which ought to be easy
for client developers to understand and adopt, and have in fact
been widely taken up.

\section{Protocol Description} \label{sec:protocol}

SAMP is based on a star topology, and its central component is a
{\em Hub\/} through which all communications are passed.
Clients first perform a resource discovery step to locate the Hub,
and then {\em register\/} with it, establishing a private communication
channel through which subsequent calls to the Hub's services can be made.
These services include accepting metadata about the registering client,
providing information about other registered clients,
and forwarding {\em messages\/} to those clients.
These messages may elicit responses, which may optionally be passed
back to the message sender, again via the Hub.
All clients are able to send messages in this way.
Any client may optionally declare itself {\em callable\/},
in which case it is also able to receive messages sent by others.
Callability is optional since it is more difficult to
achieve in client code, requiring some server-like capacity
on top of the ability to invoke Hub services.
In addition to declaring itself callable, a client wishing to
receive messages must explicitly {\em subscribe}\footnote{
   The term ``subscription'' derives from the ``publish/subscribe''
   messaging pattern.  It may however be more helpful to think of
   subscription as {\em declaring support for\/} a particular message type.
}
to one or more {\em MTypes} (message types).
Every message is labelled with an MType,
and the Hub will only deliver messages to clients
that have declared their interest in the MType in question with
an appropriate subscription.  When sending messages, clients may
either {\em broadcast\/} them to all subscribed clients or
target them to a named client, but in the latter case delivery
will fail if the target client has not appropriately subscribed.
If a client has no further use for SAMP communications
(for instance on application exit), it can and should {\em unregister\/}.

The details of this pattern are fleshed out in a three-layer architecture:
\begin{description}
\item[Abstract API:] defines the services provided by the Hub and clients
\item[Profile:] maps the Abstract API to specific communication operations,
  such as bytes on the wire
\item[MTypes:] provide semantics for the actual messages exchanged between
  clients
\end{description}

Note that SAMP thus defines two distinct sets of
Remote Procedure Call (RPC) operations:
the functions declared by the Abstract API,
concerning the mechanics of client-hub communication and message delivery,
and SAMP Messages themselves classified by MType,
bearing the application-level content that clients wish
to exchange with each other.
The syntax and semantics of the former are carefully defined by the
SAMP standard, but the form and content of the latter are
agreed outside of SAMP itself by cooperating client developers.
% By the same token, message semantics are outside the scope of the
% messaging infrastructure, so hub implementations and client toolkits
% treat all messages without regard to their semantic content.

Because of the central r\^{o}le of the Hub in this pattern,
it presents a single point of failure and potential bottle-neck.
However, SAMP messages are usually short,
and in practice performance issues have not generally been apparent.

The following subsections present a more detailed account of
these ideas, along with some of the considerations that influenced
their design.
Sections \ref{sec:abstractApi}, \ref{sec:profile} and \ref{sec:mtypes}
describe the three architectural layers,
and sections \ref{sec:typeSystem} and \ref{sec:extVocabs}
describe the underlying type system and how it is used to underpin
extensibility in SAMP.
For full details, see the SAMP Standard \citep{samp_std}.

\subsection{Abstract API} \label{sec:abstractApi}

The Abstract API defines the messaging capabilities of SAMP.
It takes the form of a list of a dozen or so function definitions
with typed arguments and return values, and well-defined semantics.
Most of these functions represent services provided by the Hub, such as
{\tt register} (which returns information required by the
client for future communications, typically an identification token)
or {\tt notifyAll} (which requests forwarding a given message to
all appropriately subscribed clients).
The rest represent services required from callable clients, such as
{\tt receiveNotification} (which consumes a given message originating
from another client).

The messaging model in principle associates
a response with every message, containing at least a completion
status flag along with zero or more MType-defined return values.
However it is up to the sending client whether a response is
required from any given message, and if not the ``send-and-forget''
({\em notification\/}) pattern may be used,
with lower cost for sender, recipient and hub.
Message processing is fundamentally asynchronous from the
receiver's point of view, so that message/response times are
not limited to the lifetime of an RPC call in the underlying
transport mechanism, but the Hub provides an optional synchronous
fa\c{c}ade for sending messages when clients expect fast turnaround
and wish to avoid the additional complication of asynchronous processing.




\subsection{Profile} \label{sec:profile}

A particular SAMP Profile is what
turns the Abstract API into a set of rules
that a client can actually use to communicate with a running Hub,
and hence with other clients.

It performs two main jobs: first, it describes
how the functions defined by the API are turned into concrete
communication operations, by specifying an RPC-capable
transport mechanism and rules for mapping the SAMP
data types into the parameters and responses used by that mechanism.
Second, it defines a hub discovery mechanism,
which tells clients how to establish initial communications with the Hub,
usually involving some authentication step.
Particular profiles may also specify additional
profile-specific hub or client services exposed as functions
alongside those mandated by the Abstract API.

Initially (SAMP 1.11, 2009)
only a single profile was defined, the Standard Profile.
This uses XML-RPC\footnote{
   XML-RPC is a simple protocol for remote procedure calling
   based on HTTP and XML. It resembles a very much slimmed-down SOAP.
   Documentation can be found at \url{http://www.xmlrpc.com/}.
}
as a transport mechanism,
and allows hub discovery by storing the URL of the hub's XML-RPC server
along with a secret randomly generated key in a private ``lockfile''
in the user's home directory.

Version 1.3 of the standard (2012) introduced a second, the Web Profile,
for use by web-based clients.
This is required for applications running within web pages,
since the sandboxed environment imposed by the browser
makes the Standard Profile inaccessible.
It shares use of XML-RPC and some other characteristics with the
Standard Profile, but hub discovery has to be done differently,
and there are a number of complications to do with security,
described in \citet{adassxxi_paper} as well as the Standard.

This decoupling between the functionality of the service interface
and its incarnation in a specific transport mechanism
allows different transports to be introduced without changes to the core
protocol or existing clients, and has a number of benefits.
In a given SAMP session, a client may use the most appropriate
Profile for its SAMP communications and exchange
messages seamlessly with other clients using different profiles;
a desktop application can exchange messages with a web page
just as easily as with another desktop client.
This works because clients only ever
communicate directly with the Hub and not with each other,
while the Hub performs lossless translation between
profile-specific network operations
and the messaging model defined by the Abstract API.

Future requirements may result in additional Profile definitions,
and there is nothing in principle to prevent hub developers
from implementing new ones outside the frame of the SAMP standard.
However, from an interoperability point of view it is important
that all profiles are supported by all common Hub implementations,
so that a client can rely on the availability of a chosen profile
in a SAMP environment, and for this reason unnecessary proliferation
of profiles is discouraged.

% The main use case underlying this decoupling when was to accommodate the
% possibility of future transports with different requirements for
% security, ease of use, reliability or performance.
% To date, alternative profiles along these lines have not been
% defined, but the success of the Web Profile in fitting into the
% scheme serves as a vindication of the design.


\subsection{MTypes} \label{sec:mtypes}

An MType (message type) is the description for a message with particular
syntax and semantics.
It is analogous to a function definition in an API,
and consists of a labelling string (sometimes also known as the MType)
along with
a set of zero or more typed and named arguments,
a set of zero or more typed and named return values,
and some associated semantics indicating what the sender of such a
message is trying to convey.

A commonly used MType is {\tt image{\kdot}load{\kdot}fits},
defined like this:
\begin{quote}
  {\em Name:\/} \\
    \hspace*{1em} {\tt image{\kdot}load{\kdot}fits} \\
  {\em Semantics:\/} \\
    \hspace*{1em} Loads a 2-d FITS image \\
  {\em Arguments:\/} \\
    \hspace*{1em} {\tt url} (string): \\
    \hspace*{2em} URL of the image to load \\
    \hspace*{1em} {\tt image-id} (string, optional): \\
    \hspace*{2em} Identifier for use in subsequent messages \\
    \hspace*{1em} {\tt name} (string, optional): \\
    \hspace*{2em} Name for labelling loaded image in UI \\
  {\em Return Values:\/} \\
    \hspace*{1em} None.
\end{quote}

The label is a short hierarchical string composed of atoms separated
by the ``.'' character.
As well as identifying to a recipient the type of an incoming message,
it is used by clients to {\em subscribe\/} to messages, that is to
indicate to the Hub which messages they are prepared to receive.
For the purpose of subscription a limited wildcarding syntax is available,
so by using the MType patterns
{\tt image{\kdot}load{\kdot}fits}, {\tt image.*} or {\tt *}
a client may declare interest in only the above message,
or all image-related messages, or all messages respectively.
% The intention is that the naming scheme should follow a hierarchical
% scheme organising MTypes by function; in fact MType labels have
% been assigned somewhat haphazardly.

In general, a callable client will only subscribe to those MTypes on which
it can meaningfully act, so for instance an image analysis tool
typically would subscribe to {\tt image{\kdot}load{\kdot}fits},
but not to {\tt spectrum{\kdot}load{\kdot}ssa-generic}.
A client that has an image FITS file to send can then
either query the Hub for those clients subscribed to the image load
message and offer its user the choice of which one to target,
or {\em broadcast} the image load message to the Hub, which will
take care of forwarding it to all (and only) the image-capable clients.

\subsection{Type System} \label{sec:typeSystem}

Supporting the function list defined by the Abstract API
and the parameters and return values specified by MTypes
is a type system defining the types of value permitted,
as well as rules for encoding various structured objects
using these types: message objects themselves, success and failure
message responses, application metadata, and MType subscription lists.

This system contains only three types:
string, list and map.
A string is a sequence of 7-bit ASCII printable characters,
a list is an ordered sequence of strings, lists or maps, and
a map is an unordered set of associations of string keys with values
of type string, list or map.
Structured objects are specified by the use of well-known keys in maps,
there is no special representation for null values,
and non-string scalar types must be serialized as strings.
(Obvious) conventions are suggested for serializing
integer, floating point and boolean values into string form,
but these suggestions are provided for the convenience
of MType definitions that wish to exchange such values without
reinventing the wheel, and are not a normative part of the protocol.

This restricted type system has been deliberately chosen to introduce
minimal dependency on the details of
non-core parts of the message delivery system,
in particular profile-specific transport mechanisms and language-specific
client libraries.
This both reduces the restrictions on what languages and transport layers
may be used with SAMP, and ensures that values transmitted will
not be modified during processing by parts of the messaging system
outside of client control.

% Experience with PLASTIC showed that in loosely-typed languages
% such as Python and Perl it was difficult to control where type
% conversions were made.

The type system is rich enough to represent complex structured data
where required, but note it is not intended for use with
binary data, and transmission of bulk data or large payloads
in general is discouraged within SAMP messages in favour of
passing URLs around instead.
This means that client and Hub implementations can work on the assumption
of short message payloads.
However it does place an additional burden on clients sending data,
since to transmit a bulk data item (such as a table or image)
not already available from an existing URL
it is necessary to make it so available, for instance by writing
bytes to a temporary file or serving them from an embedded HTTP server.

\subsection{Extensible Vocabularies} \label{sec:extVocabs}

Extensibility is built into this system via the notion of an
{\em extensible vocabulary} used when representing structured objects.

Structured objects are represented as maps with well-known keys,
but the rule is that additional keys are always permitted,
and that hubs and clients must ignore any keys they do not understand,
propagating them to downstream consumers where applicable
(compare the NDF extension architecture described in \citet{sgp38}).
A corollary is that such non-well-known keys must be defined in such
a way that ignoring them will result in reasonable behaviour.
The Abstract API tends to prefer maps (unordered name/value pairs)
over ordered parameter value lists, which makes this extensibility
pervasive throughout the messaging system,
applying for instance to
client metadata and subscription declarations,
message transmission information,
and MType-specified message parameter lists and return values.

For instance, a client sending a message must pass it to the Hub
as a map with two required keys:
{\tt samp{\kdot}mtype} giving the MType label and
{\tt samp{\kdot}params} giving the MType-specified parameter list
(itself a map).
But a client may optionally insert additional non-standard key/value pairs
into that map, for instance using a non-standard key {\tt priority}
to associate a particular priority level with the message.
If the Hub happens to support this non-standard feature,
it is able to treat the message specially in view of this declaration;
in any case it will propagate the message to recipient clients
with the additional entry present, so if one of those supports
this feature then it may use the value in processing.
The same rule applies for instance to the MType-determined
message parameter list;
an MType like {\tt image{\kdot}load{\kdot}fits}
has a required parameter {\tt url},
but a sending client may add a non-standard parameter like
{\tt colormap} (or {\tt ds9{\kdot}colormap}) alongside the well-known ones
for the benefit of any client that happens to support it.
Clients can therefore piggy-back experimental or application-specific
instructions on top of generic messages to achieve more detailed control
where available, falling back to the baseline functionality if it is not.
Using this extensibility pattern, new or enhanced features of 
particular MTypes or of the protocol itself can be prototyped 
very easily, requiring no changes to the SAMP standard or infrastructure
implementation beyond those components actually using
the non-standard features,
and imposing no negative impact on existing messaging operations.
If they are found to be useful, they may be adopted in the future
as (most likely optional) well-known keys alongside the original ones.

Some associated namespacing rules apply.
Well-known keys defined by the SAMP standard are in the reserved {\tt samp}
namespace, meaning they begin with the string ``{\tt samp.}''.
When introducing non-standard keys it is not permitted to use this
namespace, but any other syntactically legal string is allowed.
The special namespace {\tt x-samp} is available
for keys proposed for future incorporation into the standard,
and hubs and clients should treat keys which differ 
only in the substitution of {\tt samp} for {\tt x-samp} as identical,
to ease standardisation of prototype features.
In the case of MType parameters and return values,
which are mostly not defined by SAMP itself, there is no reserved namespace.

%% I already alluded to this (Interoperability design)
% These rules do not defend against all possibility of namespace clashes,
% but in practice that has not been a problem,
% and the decision to use short readable strings
% instead of rigidly namespaced sequences such as URIs
% (which was the rule in PLASTIC) looks in hindsight to be a good one.

%% I already said this ("tends to prefer maps")
% Note that the transmission of parameter values as name/value pairs
% rather than ordered value lists naturally facilitates this kind of
% extensibility.

\section{Use in Practice} \label{sec:usage}

\subsection{Client Ecosystem}

{\todo tolerance of failure, hub startup/shutdown handling}

{\todo move some of the MType stuff up here?}

\subsection{Existing Software}

\subsection{MType Content}

The utility and success of a messaging infrastructure for
a particular problem domain relies on having suitable
message semantics to go with it.
SAMP can only be a useful tool for astronomical data analysis
if there exists a suitable library of MTypes for communicating
the information that applications need in practice to exchange,
given that any given MType is only useful if at least two,
and preferably many, potentially cooperating clients
understand and can act upon it.
The description of MType syntax and handling in section \ref{sec:mtypes}
says nothing about how such a library is to be assembled.
There are two parts to this question:
what kinds of messages do we want to be able to exchange,
and what is the process by which a list of such message types
should be arrived at and publicised.
These are addressed in the following subsections.

\subsubsection{MType Semantics}

The most obvious approach for providing message-based control
of an application
is to identify (at least some of) the capabilities it offers and
define a messaging interface with parameters and return values
exposing those capabilities.  An image display application might
expose a set of MTypes allowing image load into a new window,
zoom configuration, colour map choice, WCS display and so on.
This allows other applications to control its behaviour
in detail and is suitable for tight integration of a known set
of tools with a good understanding of each other's capabilities,
for instance to execute a pre-orchestrated sequence of processing steps.

However, this approach is less effective in less predictable environments.
The controlling client needs to understand
the capabilities of its partner client in order to control it.
But if the set of tools in use at runtime is chosen by a
user from an open-ended set
rather than mandated by a developer, the identity of the
partner client or clients is not known in advance.
In general, different applications have different capability sets
and internal data models, and these cannot readily be encompassed
by any single general abstraction.
Different image display tools
may support different data formats,
may or may not support multiple loaded windows or images,
may specify zooms in different ways,
may offer different selections of colour maps,
may provide WCS display with different options or not at all
and so on,
and the burden on a client wishing to control a range
of different recipients quickly becomes large.
Even if an application developer is prepared to study the
messaging APIs offered by existing available tools and implement logic
managing message dispatch for each case,
the resulting code will not cope with applications
unknown to the developer,
for instance ones which have not yet been written.

For uncontrolled environments in which the user selects
the range of cooperating tools at runtime therefore,
a ``loose integration'' model has turned out to be much more productive.
This approach focuses on a messaging interface
consisting of a fairly small number of MTypes with
semantics that are non-client-specific and rather vague.
The semantics of the most-used messages generally boils down to
``{\em Here is an X}'', where $X$ may be some resource type such as a
table, image, spectrum,
sky position, coverage region, bibcode etc,
or sometimes a reference to an $X$ from a previous message,
for instance a row selection relating to an earlier-sent table.
The implication of such an MType is that the receiver should do
something with the $X$ in question: load, display, highlight,
or otherwise perform some action which makes sense given the
receiving application's capabilities.
Callable SAMP clients should therefore advertise themselves
(by subscribing to the appropriate MTypes) as $X$-capable
tools only if they are in a position to do something sensible
with an $X$ should they be presented with one.
Such an advertisement serves as a hint to potential $X$-senders,
though it does not constitute a guarantee of any particular behaviour.
This framework typically manifests itself in a client user interface
as an option, for an $X$ currently known by that client,
either to {\em broadcast\/} it to all $X$-capable clients,
or to target it to an entry selected by the user
from a dynamically-discovered list of $X$-capable clients.

For clients to interoperate as reliably as possible in this scenario,
it is not sufficient just to agree on the notion of a table or an image
for exchange, it is also necessary to specify the exact data exchange
format.
In the case of tabular data, a variety of possible exchange formats
is in common use: FITS binary and ASCII tables, VOTable,
Comma-Separated Values and a host of others including 
many ASCII-based variants.  Different choices are convenient in
different usage contexts, suggesting the need for a variety of
distinct format-specific MTypes.
However, a proliferation of alternative exchange formats,
though superficially convenient, erodes interoperability.
If multiple exchange formats capaple of serializing the same thing
are available,
the sender has to choose which to send, and the receiver may or
may not be able to receive it.
Well-behaved recipients should include conversion code for as many
formats as possible, and well-behaved senders should send data
in a format dependent on what is supported by the intended recipient.
For applications willing to expend a lot of effort on interoperability 
the work required at both ends increases rapidly with the number of
available formats, and the rest may find themselves unable to
exchange data of essentially compatible types,
or the community of SAMP clients may fragment into format-specific
sub-communities unable to communicate globally.
As much as possible therefore, it is desirable to restrict the options
to a single well-defined exchange format for each basic data type.

This can be a difficult balance to get right.
In the case of images, astronomy is fortunate that FITS serves as
the {\em lingua franca\/}, and the only commonly-used MType is
{\tt image{\kdot}load{\kdot}fits}.
For tabular data, clients are strongly encouraged to use
{\tt table{\kdot}load{\kdot}votable} even if it means translating to/from
some other format; however other {\tt table{\kdot}load.*} variants are in use,
for instance for the CDF format\footnote{\url{http://cdf.gsfc.nasa.gov/}},
which though tabular is
not readily translated to VOTable without loss of information,
and which tends to be used in communities not familiar with VOTable.
In the case of spectra, for various reasons related to the
form in which spectral data is typically obtained and
the typical capabilities of spectrum-capable clients,
the relevant MType is {\tt spectrum{\kdot}load{\kdot}ssa-generic},
which allows any format to be used for the spectral data,
with additional parameters specifying
the format actually in use.

SAMP is capable of supporting both tight and loose integration,
and both are in use,
but for coupling interactive data analysis tools the loose integration
model has proven the most productive,
and able to support ways of working that have not been possible
using other available messaging systems.

\subsubsection{MType Definition Process}

In the case of application-specific MTypes, the documentation of
available MTypes and their definitions is clearly
best handled as part of the documentation of the application itself.
These typically provide functionality that only makes sense for
a given tool, and make use of a suitably specific namespace,
for instance {\tt script{\kdot}aladin{\kdot}send},
which allows external applications to control Aladin
\citep{2000A&AS..143...33B} using commands in its scripting language.

Developers are also free to define their own MTypes for use privately
or in some closed group with locally agreed conventions for documentation,
perhaps to support some tight-coupling-like usage.

However, for well-known MTypes intended for unrestricted use,
for instance of the loose-coupling variety described above,
some public process is required to establish
and publicise their definitions, so that client developers can
both contribute their requirements for functionality, and become aware
of the conventions in use by other tools.

One possibility
is to decide on a fixed list to form part of the SAMP standard.
A small number of ``administrative'' MTypes,
concerned with the messaging infrastructure,
for instance {\tt samp{\kdot}hub{\kdot}event{\kdot}register}
which informs existing clients when a new client has registered,
have been written in to the standard in this way.
All of these are in the reserved {\tt samp.} namespace.
However, for astronomy-specific MTypes this option was rejected,
partly in order to avoid the introduction of astronomy-specific details
into a standard which is otherwise quite suitable for use in other domains,
and partly because the rather heavyweight IVOA process for
standard review \citep{ivoadoc}
(draft to acceptance rarely taking less than 12 months)
would impede introduction and updating of MTypes as required
by implementation experience and new application demands.
Another option is periodic publication of MType definitions
in an IVOA Note.  Such Notes may be issued at will without formal review,
but no straightforward updating mechanism is in use,
and this option was still felt to be undesirably cumbersome.

Instead, a wiki page\footnote{
  At time of writing, this wiki page can be found near
  \url{http://www.ivoa.net/samp/}.
  If the process for MType publication changes in the future,
  that URL should still indicate where to look for a list.}
was set up on the IVOA web site listing currently agreed MTypes.
An informal understanding was adopted in which
application developers are encouraged to discuss requirements for
new MTypes or modifications to existing ones either privately or
on the associated mailing list\footnote{apps-samp@ivoa.net}, 
and if consensus is reached, to edit the wiki page accordingly.
This was intended as a provisional measure to be reviewed and
modified as required, but, six years later, the need for a more
formal process has not been apparent, and there are no current
plans to modify this arrangement.

\section{Conclusions} \label{sec:conclusion}

{\todo
\begin{itemize}
\item Successes:
      API/Profile split (vindicated by web profile),
      lightweight semantics process (small community, IVOA forum helps),
      restricted type system,
      extensible vocabularies
      (lessons for IVOA/other projects?)
\item Lessons learned:
      some misfeatures: better logo would be nice,
      JSON might have made more sense,
      metadata/subs should be on registration,
      Unicode?
\item Possible future directions:
      cross-host messaging/collaboration,
      more secure/reliable transports (or not),
      use outside of astronomy?
      use from python might drive different directions/new MTypes
         (pull rather than push semantics)
\end{itemize}
}

{\todo
What makes it work well is the combination of pub/sub, vague semantics
and ease of adoption (leading to wide uptake).  This means it can go
places that earlier protocols like XPA couldn't.
}
  

\section*{References}

\bibliography{bibsamp}

\end{document}
