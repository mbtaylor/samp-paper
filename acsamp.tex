%% A&C uses 5p
\documentclass[5p]{elsarticle}

\usepackage{hyperref}
\usepackage{graphicx}

\journal{Astronomy \& Computing}

%% A&C uses model2-names (Harvard)
\bibliographystyle{model2-names}\biboptions{authoryear}

%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{frontmatter}

\title{SAMP, the Simple Applications Messaging Protocol}

%% Group authors per affiliation:
\author[bristol]{M.~B.~Taylor}
\ead{m.b.taylor@bristol.ac.uk}
\author[cds]{T.~Boch}
\author[google]{J.Taylor}

\address[bristol]{H.~H.~Wills Physics Laboratory, University of Bristol, UK}
\address[cds]{CDS, Observatoire Astronomique de Strasbourg, France}
\address[google]{Google, USA}

\begin{abstract}
SAMP, the Simple Applications Messaging Protocol, is a
hub-based communication standard for the exchange of data and control
between participating client applications.
It has been developed within the context of the Virtual Observatory
with the aim of enabling specialised data analysis tools to cooperate
as a loosely integrated suite, and is now in use by many and varied
desktop and web-based applications dealing with astronomical data.
This paper reviews the requirements and design principles that led to
SAMP's specification, provides a high-level description of the protocol,
and discusses some of its common and possible future usage patterns.
\end{abstract}

% is there a controlled/recommended vocabulary?
% from http://dl.acm.org/ccs_flat.cfm
\begin{keyword}
message-passing
publish-subscribe
interoperability
\end{keyword}

\end{frontmatter}

\section{Introduction}

% try to avoid re-writing adass_xxi intro

Astronomical research requires complex and flexible manipulation
and processing of various different types of data.
Images, spectra, catalogues, time series, coverage maps and other data
types need their own special handling,
typically provided by specialist tools.
% and in many cases the required capabilities are provided by tools that
% specialise in a particular data type.
Data sets of different types meanwhile are usually related
in various ways arising from their physical origin,
for instance
catalogues are often derived from images and best understood in
conjunction with them, and
spectra and time series usually originate from specific sky positions
or regions which may be represented on images and described by
catalogue entries.
To extract scientific meaning from the data it is usually necessary
to exploit these linkages between data items as well as the
internal structure of each.

The working astronomer therefore uses a selection of different tools,
each specialising in a particular type of data or manipulation,
for different data sets and different tasks,
and has to integrate these together in a way that takes account of
the relationships of the data items under consideration.
For batch or pipeline-type processing this is usually, in terms of
data flow, fairly straightforward: the output of one step can be
fed to the input of the next as a file, stream of bytes, or some
kind of parameter list, often under the control of a script of some kind.

During the exploratory or interactive phase of data analysis however,
this traditional model of tool integration is less satisfactory.
Within a given GUI analysis
tool it is usual to interact with the data using
mouse and keyboard gestures to perform actions like selection or
navigation with instant visual feedback, in many cases with some
kind of internal linkage between different data views.
But communicating such actions or their results between different
tools tends to be much more cumbersome.
A way can often be found to reflect a result generated by one tool
in the state of another, for instance by reading sky coordinates
reported by one tool and typing or pasting them into another,
or saving an intermediate result from one tool to temporary storage
and reloading it into another, but it can be fiddly and tedious,
especially if similar actions are required repeatedly.
This lack of convenience is more than just an annoyance, it can
interrupt the flow of the data exploration, reduce the parameter
space able to be investigated, and effectively stifle discovery
of relationships present in the data.

% should there be a concrete example?
% is this stating the obvious?
% is the introduction far too long?

From this point of view, a single monolithic astronomical data analysis
user application providing the best available facilities for
interactive presentation, manipulation and analysis of all kinds of
astronomical data and their interrelationships seems an attractive prospect.
In reality of course, no such one-stop analysis tool exists.
The obvious practical difficulties aside, it is not even clear
that deviating so far from the Unix philosophy of
``Make each program do one thing well'' \citep{mcilroy1978}
would be desirable.

These considerations have driven the development of a framework
for communication between independently-developed software items,
written in different languages and running in different processes.
Such applications can thus be made to appear to the user
as a loosely integrated suite of cooperating tools,
providing facilities such as data exchange, linked views and
remote control between each other.
Although communication between interactive desktop tools was the
original stimulus for what is now SAMP, the framework is flexible
enough to support other usage patterns as well.

Two previous papers on SAMP have been presented at the ADASS conference
series:
\citet{adassxxi_paper} outlines the architecture and explains
the Web Profile, and \citet{adassxxii_bof} lists some existing
client libraries.
This paper discusses the protocol design and communication model
in somewhat more detail, though at a higher level than given by the
standard itself \citep{samp_std}, and reviews existing and current
usage, considering lessons learned and possible future directions.
Section \ref{sec:history} outlines its evolution from
the earlier PLASTIC protocol,
section \ref{sec:protocol} presents a description of the protocol itself
along with some of the thinking for the design behind it,
section \ref{sec:usage} gives some examples of its use in practice, and
section \ref{sec:conclusion} concludes by reviewing the current status
and possible future directions for SAMP.

\section{History} \label{sec:history}
 
SC4DEVO ... VOTech ... VODesktop ... AstroGrid Runtime ...
PLASTIC ... pub/sub ... XML-RPC/Java/RMILite
\citep{plastic_note}


% needs work.  Or removing.
\section{Design Principles} \label{sec:design}

Many factors fed into the design of SAMP,
including positive and negative lessons learned
from the experience of PLASTIC, 
general good practice etc.
The overriding objective here is to foster interoperability in practice,
which requires wide take-up of the standard in candidate applications.

To achieve this, the following principles were followed as much as possible:
\begin{itemize}
\item Ease of adoption
\item Platform independence
\item Extensibility
\item Avoid standardising semantics
\item Small messages
\end{itemize}


\section{Protocol Description} \label{sec:protocol}

SAMP is based on a star topology, and its central component is a
{\em Hub\/} through which all communications are passed.
Clients first perform a resource discovery step to locate the Hub,
and then {\em register\/} with it, establishing a private communication
channel through which subsequent calls to the Hub's services can be made.
These services include accepting metadata about the registering client,
providing information about other participating clients,
and forwarding {\em messages\/} to those clients.
These messages may elicit responses, which may optionally be passed
back to the message sender, again via the Hub.
All clients are able to send messages in this way.
Any client may optionally declare itself {\em callable\/},
in which case it is also able to receive messages sent by others.
Callability is optional since it is more difficult to
achieve in client code, requiring some server-like capacity
on top of the ability to invoke Hub services.
In addition to declaring itself callable, a client wishing to
receive messages must explicitly {\em subscribe\/} to one or
more {\em MTypes} (message types).  Every message is labelled
with an MType, and the Hub will only deliver messages to clients
that have declared their interest in the MType in question with
an appropriate subscription.  When sending messages, clients may
either {\em broadcast\/} them to all subscribed clients or
target them to a named client, but in the latter case delivery
will fail if the target client has not appropriately subscribed.
If a client has no further use for SAMP communications
(for instance on application exit), it can and should {\em unregister\/}.

The details of this pattern are fleshed out in a three-layer architecture:
\begin{description}
\item[Abstract API:] defines the services provided by the Hub and clients
\item[Profile:] maps the Abstract API to specific communication operations,
  such as bytes on the wire
\item[MTypes:] provide semantics for the actual messages exchanged between
  clients
\end{description}

It is important to understand that SAMP defines two distinct sets of
Remote Procedure Call (RPC) operations:
the functions declared by the Abstract API,
concerning the mechanics of client-hub communication and message delivery,
and SAMP Messages themselves classified by MType,
bearing the application-level content that clients want
to exchange with each other.
The syntax and semantics of the former are carefully defined by the
SAMP standard, but the form and content of the latter are
agreed outside of SAMP itself by cooperating client developers.
By the same token, message semantics are outside the scope of the
messaging infrastructure, so hub implementations and client toolkits
treat all messages without regard to their semantic content.


The following subsections describe each of the three architectural layers,
along with some of the considerations that influenced their design.
For full details, see the SAMP Standard \citep{samp_std}.

\subsection{Abstract API}

The Abstract API defines the messaging capabilities of SAMP.
It is provided in the form of a list of a dozen or so function definitions
with typed arguments and return values, and well-defined semantics.
Most of these functions represent services provided by the Hub, such as
``{\tt register}'' (which returns information required by the
client for future communications, typically an identification token)
or ``{\tt notifyAll}'' (which requests forwarding a given message to
all appropriately subscribed clients).
The rest represent services required from callable clients, such as
``{\tt receiveNotification}'' (which consumes a given message originating
from another client).

Alongside this function list goes a type system defining the types of value
used in the API, as well as rules for encoding various structured objects
using these types: message objects themselves, success and failure
message responses, application metadata, and MType subscription lists.

This type system contains only three types:
string, list and map.
The map is a set of associations of string keys with
values that are themselves of type string, list or map.
Structured objects are specified by the use of well-known keys in map values,
null values are not permitted,
and non-string scalar types must be serialized as strings.
(Obvious) conventions are suggested for serializing
integer, floating point and boolean values,
but these suggestions are provided for the convenience
of MType definitions that wish to exchange such values without
reinventing the wheel, and are not a normative part of the protocol.
This restricted type system has been deliberately chosen to introduce
minimal dependency on the details of
non-core parts of the message delivery system,
in particular profile-specific transport mechanisms and language-specific
client libraries.
This both reduces the restrictions on what languages and transports
may be used with SAMP, and ensures that values transmitted will
not be modified during processing by parts of the messaging system
outside of client control.
% Experience with PLASTIC showed that in loosely-typed languages
% such as Python and Perl it was difficult to control where type
% conversions were made.
% Better mention that it won't carry bulk binary data.

Because of the central r\^{o}le of the Hub in this pattern,
it presents a single point of failure and potential bottle-neck.
% In practice, this has not generally led to performance issues.
For this reason, the API is arranged where possible
to minimise the internal state the Hub is required to maintain;
for instance long-lived asynchronous messages need not consume
Hub resources between delivery and response, since the required
state (sender, hence recipient of the response) is maintained
by the message recipient.

The messaging model in principle associates
a response with every message, containing at least a completion
status flag along with zero or more return values.
However it is up to the sending client whether a response is
required from any given message, and if not the ``send-and-forget''
({\em notification\/}) pattern may be used,
with lower cost for sender, recipient and hub.
Message processing is fundamentally asynchronous from the
receiver's point of view, so that message/response times are
not limited to the lifetime of an RPC call in the underlying
transport mechanism, but the Hub provides an optional synchronous
fa\c{c}ade for clients that expect fast turnarounds and wish to
avoid the additional complication of asynchronous processing.

\subsection{Profile}

A particular SAMP Profile turns the Abstract API into a set of rules
that a client can actually use to communicate with a running Hub,
and hence with other clients.
It performs two main jobs: first, it describes
how the functions defined by the API are turned into concrete
communication operations, by specifying an RPC-capable
transport mechanism and rules for mapping the SAMP
data types into the parameters and responses used by that mechanism.
Second, it defines a hub discovery mechanism,
which tells clients how to establish initial communications with the Hub,
typically involving some authentication step.
Particular profiles may also specify provide additional
profile-specific hub or client services exposed as functions
alongside those mandated by the Abstract API.

Initially (SAMP 1.11, 2009)
only a single profile was defined, the Standard Profile.
This uses XML-RPC as a transport mechanism,
and provides hub discovery by storing the URL of the hub's XML-RPC server
along with a secret hub-generated key in a private ``lockfile''
in the user's home directory.

Version 1.3 of the standard (2012) introduced a second, the Web Profile,
for use by browser-based clients.
This is required for web applications since the sandboxed environment
in which they are run makes the Standard Profile inaccessible.
It shares use of XML-RPC and some other characteristics with the
Standard Profile, but hub discovery has to be done differently,
and there are a number of complications to do with security,
described in \citet{adassxxi_paper} as well as the Standard.

This decoupling between the functionality of the service interface
and its incarnation in a specific transport mechanism
allows different transports to be introduced without changes to the core
protocol or existing clients, and has a number of benefits.
In a given SAMP session, a client may use the most appropriate
Profile for its SAMP communications and exchange
messages seamlessly with other clients using different profiles
without ever being aware of that fact.
This works because clients only ever
communicate directly with the Hub and not with each other,
and the Hub translates profile-specific calls to and from
the messaging model defined by the Abstract API.

Future requirements may result in additional Profile definitions,
and there is nothing in principle to prevent hub developers
from implementing new ones outside the frame of the SAMP standard.
However, from an interoperability point of view it is important
that all profiles are supported by all common Hub implementations,
so that a client can rely on the availability of a chosen profile
in a SAMP environment, and for this reason unnecessary proliferation
of profiles is discouraged.

% The main use case underlying this decoupling when was to accommodate the
% possibility of future transports with different requirements for
% security, ease of use, reliability or performance.
% To date, alternative profiles along these lines have not been
% defined, but the success of the Web Profile in fitting into the
% scheme serves as a vindication of the design.


\subsection{MTypes}

An MType (message type) is the description for a message with particular
syntax and semantics.
It is analogous to a function definition in an API,
and consists of a labelling string (sometimes also known as the MType)
along with
a set of zero or more typed and named arguments,
a set of zero or more typed and named return values,
and some associated semantics indicating what the sender of such a
message is trying to convey.

A commonly used MType is ``{\tt image.load.fits}'',
defined like this:
\begin{quote}
  {\em Name:\/} \\
    \hspace*{1em} {\tt image.load.fits} \\
  {\em Semantics:\/} \\
    \hspace*{1em} Loads a 2-d FITS image \\
  {\em Arguments:\/} \\
    \hspace*{1em} {\tt url} (string): \\
    \hspace*{2em} URL of the image to load \\
    \hspace*{1em} {\tt image-id} (string, optional): \\
    \hspace*{2em} Identifier for use in subsequent messages \\
    \hspace*{1em} {\tt name} (string, optional): \\
    \hspace*{2em} Name for labelling loaded image in UI \\
  {\em Return Values:\/} \\
    \hspace*{1em} None.
\end{quote}

The label is a short hierarchical string composed of atoms separated
by the ``.'' character.
As well as identifying to a recipient the type of an incoming message,
it is used by clients to {\em subscribe\/} to messages, that is to
indicate to the Hub which messages they are prepared to receive.
For the purpose of subscription a limited wildcarding syntax is available,
so by using the MType patterns
``{\tt image.load.fits}'', ``{\tt image.*}'' or ``{\tt *}''
a client may declare interest in only the above message,
all image-related messages, or all messages respectively.

In general, a callable client will only subscribe to those MTypes on which
it can meaningfully act, so for instance an image analysis tool
typically would subscribe to {\tt image.load.fits},
but not to {\tt spectrum.load.ssa-generic}.
A client that has an image FITS file to send can then
either query the Hub for those clients subscribed to the image load
message and offer its user the choice of which to send it to,
or {\em broadcast} the image load message to the Hub, which will
take care of forwarding it to all (and only) the image-capable clients.

The above description of MType syntax and handling says
nothing about how particular MTypes are to be defined.
In order to support useful messaging, a common set of MTypes
describing data and control exchange operations required for
a particular problem domain must be agreed upon by authors of
cooperating applications and publicised for future use.

One possibility would be to decide on a fixed or open-ended list of
such MTypes to form part of the SAMP standard.
A small number of ``administrative'' MTypes,
concerned with the messaging infrastructure,
for instance ``{\tt samp.hub.event.register}''
which informs existing clients when a new client has registered,
have been included in the standard in this way.
All of these are in the reserved ``{\tt samp.}'' namespace.
However, for astronomy-specific MTypes this option was rejected,
partly in order to avoid the introduction of astronomy-specific details
into a standard which is otherwise quite suitable for use in other domains,
and partly because the rather heavyweight IVOA process for
standard review\citep{ivoadoc}
(draft to acceptance rarely taking less than 12 months)
would impede introduction and updating of MTypes as required
by implementation experience and new application demands.
Another option was periodic publication of MType definitions
in an IVOA Note.  Notes may be issued at will without formal review,
but no straightforward updating mechanism is in use,
and this option was still felt to be undesirably cumbersome.

Instead, a wiki page was set up on the
IVOA web site listing currently agreed MTypes.
An informal understanding was adopted in which
application developers are encouraged to discuss requirements for
new MTypes or modifications to existing ones either privately or
on the associated mailing list\footnote{apps-samp@ivoa.net}, 
and if consensus is reached, to edit the wiki page accordingly.
This was intended as a provisional measure to be reviewed and
modified as required, but, six years later, the need for a more
formal process has not been apparent, and there are no current
plans to modify this arrangement.

As well as those generic MTypes which need public agreement,
clients are at liberty to define their own application-specific ones.
These typically provide functionality that only makes sense for
a given appliacation, and make use of a suitably specific namespace,
for instance ``{\tt script.aladin.send}'',
which allows external applications to control Aladin
\citep{2000A&AS..143...33B} using commands in its scripting language.




\section{Use in Practice} \label{sec:usage}

\section{Conclusions} \label{sec:conclusion}

Particularly successful: API/profile split; bottom-up semantics;
restricted type system; extensible definitions
  

\section*{References}

\bibliography{bibsamp}

\end{document}
